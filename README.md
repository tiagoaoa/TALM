# TALM / Trebuchet Research Prototype

This repository brings together the three research prototypes that form the TALM toolchain created by Tiago A. O. Alves, Leandro A. J. Marzulo and collaborators at COPPE/UFRJ:

- **Couillard** – a Python-based C front-end that emits TALM dataflow graphs and the C stubs for user-defined super-instructions (`Couillard/c.py`, `Couillard/flow.py`, `Couillard/talmvisitor.py`).
- **FlowASM** – a macro-enabled assembler for TALM graphs that turns textual `.fl` descriptions into the binary bytecode and placement files consumed by Trebuchet (`asm/assembler.py`, `asm/flowasm.py`, `asm/preprocessor.py`, `asm/scheduler.py`).
- **Trebuchet** – a multithreaded interpreter that executes TALM bytecode on a pool of processing elements with support for speculative execution, task placement and dynamically loaded super-instruction libraries (`interp/interp.c`, `interp/loader.c`, `interp/include`).

All folders still carry the original “work in progress” disclaimer (“THIS IS NOT AN OFFICIAL RELEASE – DO NOT COPY OR DISTRIBUTE”) you will notice at the top of the source files.

## Repository layout

- `Couillard/` – Parser, visitors, Graphviz emitters and samples for the Couillard compiler. `examples/` contains annotated C programs such as `helloworld`, `vectorsum`, and a CUDA integration demo.
- `asm/` – FlowASM assembler, macro preprocessor, scheduling/placement heuristics, and hand-written `.fl` / `.pla` examples that can be used to sanity-check the assembler or the interpreter.
- `interp/` – Trebuchet runtime written in C (builds the `interp` binary). Includes queue implementations, the loader, dataflow memory manager, STM hooks, and helper functions exposed to the generated super-instructions (`treb_functions.*`).

## Toolchain workflow

1. **Annotate C code with TALM extensions** – See `Couillard/examples/helloworld/hello.c` or `Couillard/examples/vectorsum/vectorsum.c` for idioms such as `treb_super`, `treb_parout`, and the `#BEGINBLOCK` / `#BEGINSUPER` markers that isolate regular C from TALM extensions.
2. **Compile with Couillard (Python 3)** – `python3 Couillard/c.py path/to/program.c` emits:
   - `<program>_lib.c`: C stubs for every `treb_super` block with argument marshalling code generated by `libvisitor.py`.
   - `<program>.fl`: textual dataflow graph instructions generated by `flow.py` / `talmvisitor.py`.
   - `<program>.dot`: Graphviz visualization (optional) plus `.ast` if `-ast` is passed on the command line.
3. **Build the super-instruction shared library** – Compile `<program>_lib.c` into something like `libinterp-blocks.so` using the Trebuchet headers (`interp/include`) and any user code referenced through `#BEGINBLOCK`.
4. **Assemble the graph** – `python asm/assembler.py -n <NUM_TASKS> -o <output-prefix> <program>.fl` produces `<output-prefix>.flb` (bytecode) and `<output-prefix>.pla` (manual placement). Passing `-a` also emits `<output-prefix>_auto.pla` using the graph builder in `asm/scheduler.py`. The assembler understands numerous macros implemented in `asm/preprocessor.py` (see the “FlowASM highlights” section).
5. **Run Trebuchet** – After `make` inside `interp/`, invoke `./interp <num_PEs> <program>.flb <program>.pla <path/to/libinterp-blocks.so> [app args...]`. The runtime loads the shared library via `dlopen()` and spawns `num_PEs` worker threads pinned to CPU cores (`interp/interp.c`).

The sample Makefiles shipped in `Couillard/examples/**/Makefile` chain these steps, so you can run `make` from one of those directories to see the entire flow.

## Couillard highlights

- Built on top of Atul Varma’s Python C front-end (`Couillard/c.py`) with extra visitors that understand `treb_super` blocks, speculative super-instructions, parallel outputs, and stream-specific annotations (see `Couillard/flow.py` and `Couillard/talmvisitor.py`).
- Emits C code that Trebuchet loads dynamically: `Couillard/libvisitor.py` creates `superN()` shims that unpack operands, call user code, and repack the results into `oper_t` objects. Runtime helpers like `treb_get_tid`, `treb_get_time`, `treb_get_n_tasks`, and argument passing APIs are provided by `interp/treb_functions.c`.
- Generates `.dot` files through `Couillard/graphvizitor.py`, making it easy to inspect the dataflow graph with Graphviz.
- Supports AST dumps (`-ast`) and annotated assembly output (`-annotate`), useful when debugging the parser or the generated TALM instructions.

## FlowASM highlights

- `asm/preprocessor.py` implements the TALM-aware macro language:
  - `callgroup(name, function)` tracks dynamically spawned call groups so that matching `callsnd` / `retsnd` instructions share tags.
  - `superinst(label, block_number, outputs, speculative=False, has_immediate=False)` rewrites the textual opcode to the right `super` / `specsuper` form and records profiling info.
  - `placeinpe(pe, mode)` switches between static and dynamic placement, while `{i=...}` blocks and `${mytid}` expressions expand to sequences of instructions for each task.
  - `setntasks(n)`, `avgtime(super_name, cycles)`, and `varprob(signal, probability)` feed the auto-placement/scheduling heuristics.
- The assembler (`asm/assembler.py` + `asm/flowasm.py`) translates the textual `.fl` file into:
  - a packed instruction stream (`.flb`) that begins with the instruction count and encodes opcode, operand fan-in/fan-out, immediates, and the connectivity lists Trebuchet expects in `loader.c`.
  - a placement file (`.pla`) listing the PE id for each instruction (first line = instruction count). The optional `_auto.pla` uses the critical-path aware scheduler in `asm/scheduler.py`.
- `asm/graphvizgen.py` can be plugged in to emit Graphviz representations straight from the assembler if you want to visualize scheduling/placement decisions.
- Instruction support mirrors Trebuchet’s ISA (`asm/flowasm.py:INSTRSET`), including speculative operations (`specsuper`, `commit`, `stopspec`), GPU transfer ops (`cphtodev`, `cpdevtoh`), and the task/tag manipulation primitives (`callsnd`, `retsnd`, `tagval`, `valtag`, `inctag*`).

## Trebuchet runtime

- `interp/interp.c` spawns one worker thread per PE, optionally binds them to CPU cores (`SET_AFFINITY`), and drives the execution loop (`pe_main`). Operands travel through lock-protected queues defined in `interp/queue.c`, and the dispatch/matching logic keeps track of tags, speculative epochs, and garbage collection.
- `interp/loader.c` reads the `.flb` stream generated by FlowASM, instantiates `instr_t` records, patches fan-out lists, and kicks off constant instructions by enqueuing them directly on the PE’s ready queue.
- `interp/treb_functions.c` exposes helper APIs to user-defined super-instructions, such as `treb_get_tid()`, `treb_get_n_tasks()`, `treb_get_time(resolution)`, and CLI argument parsing (`treb_get_arg`, `treb_get_n_args`).
- Speculation support (commit/stopspec, speculative supers, wait counters for garbage collection) is implemented in `interp/interp.c` and `interp/dfmem.c`, matching the `commit`/`stopspec` instructions emitted by FlowASM’s instruction set.
- Build with `make` from `interp/`. The binary links against `pthread`, `dl`, `rt`, and `m`. Optional STM support (`dfstm.c`) is stubbed out behind `USE_STM`.

## Examples and quickstart

```bash
# Build the interpreter
make -C interp

# Run the Hello World sample end-to-end
cd Couillard/examples/helloworld
make                     # runs Couillard, compiles the lib, assembles, and leaves hello.flb/hello.pla
../../interp/interp 4 hello.flb hello.pla ./libinterp-blocks.so
```

Other ready-to-use samples:

- `Couillard/examples/vectorsum/` – Parallel array initialization and reduction, shows `treb_parout` and indexed inputs like `y::*`.
- `Couillard/examples/cuda1/` – Demonstrates calling CUDA kernels from a `treb_super`, mixing device code (`cuda1_cuda.cu`, `pi.cu`) with the standard TALM pipeline.
- `asm/examples/*.fl` – Bare FlowASM files (with matching `.pla`s) useful when experimenting with the assembler or Trebuchet without Couillard.

## Academic references

The following publications describe the TALM model and the Trebuchet runtime in detail:

1. **Tiago A. O. Alves; Leandro A. J. Marzulo; Guido Araujo.** “Trebuchet: A Multi-threaded Implementation of the TALM Model.” *Proceedings of the International Symposium on Computer Architecture and High Performance Computing (SBAC-PAD)*, 2007.
2. **Tiago A. O. Alves.** “Trebuchet: Uma Máquina Virtual Dataflow com Suporte à Especulação.” M.Sc. Thesis, COPPE/UFRJ, 2008.

These references explain the programming model, the speculative execution mechanisms, and the experimental setups that motivated this codebase.

## Notes & next steps

- All Python tooling now targets Python 3 (tested with 3.13); make sure `python3` resolves to a recent interpreter when invoking Couillard or FlowASM scripts.
- Many files still contain Portuguese debug messages and TODOs. Keeping an eye on `DEBUG_*` defines (see `interp/Makefile`) helps when instrumenting runs.
- Because the tree predates packaging, you can treat the three top-level directories as independent projects, but the quickest way to experiment is through the sample Makefiles under `Couillard/examples`.
